# 设计模式

- 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

- 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1    | **创建型模式** 这些设计模式提供了一种在创建对象<br />的同时隐藏创建逻辑的方式，而不是使用 new 运<br />算符直接实例化对象。这使得程序在判断针对某个<br />给定实例需要创建哪些对象时更加灵活。 | **工厂模式**（Factory Pattern）<br />抽象工厂模式（Abstract Factory Pattern）<br />**单例模式**（Singleton Pattern）<br />建造者模式（Builder Pattern）<br />原型模式（Prototype Pattern） |
| 2    | **结构型模式** 这些设计模式关注类和对象的组合。<br />继承的概念被用来组合接口和定义组合对象获<br />得新功能的方式。 | 适配器模式（Adapter Pattern）<br />桥接模式（Bridge Pattern）<br />过滤器模式（Filter、Criteria Pattern）<br />组合模式（Composite Pattern）<br />装饰器模式（Decorator Pattern）<br />外观模式（Facade Pattern）<br />享元模式（Flyweight Pattern）<br />代理模式（Proxy Pattern） |
| 3    | **行为型模式** 这些设计模式特别关注对象之间的通信。          | 责任链模式（Chain of Responsibility Pattern） <br />命令模式（Command Pattern）<br />解释器模式（Interpreter Pattern）<br />迭代器模式（Iterator Pattern）<br />中介者模式（Mediator Pattern）<br />备忘录模式（Memento Pattern）<br />**观察者模式**（Observer Pattern）<br />状态模式（State Pattern）<br />空对象模式（Null Object Pattern）<br />策略模式（Strategy Pattern）<br />模板模式（Template Pattern）<br />访问者模式（Visitor Pattern） |
| 4    | **J2EE 模式** 这些设计模式特别关注表示层。<br />这些模式是由 Sun Java Center 鉴定的。 | MVC 模式（MVC Pattern）<br />业务代表模式（Business Delegate Pattern）<br />组合实体模式（Composite Entity Pattern）<br />数据访问对象模式（Data Access Object Pattern）<br />前端控制器模式（Front Controller Pattern）<br />拦截过滤器模式（Intercepting Filter Pattern）<br />服务定位器模式（Service Locator Pattern）<br />传输对象模式（Transfer Object Pattern） |

## 常见的设计模式

**单例模式**：单例模式主要解决一个**全局使用的类频繁的创建和销毁的问题**。单例模式下可以**确保某一个类只有一个实例**，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是**某个类只能有一个实例**；二是它**必须自行创建这个实例**；三是它必须**自行向整个系统提供这个实例**。

**工厂模式**：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。

**观察者模式**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

## [单例模式](https://www.runoob.com/design-pattern/singleton-pattern.html)

单例模式主要解决一个**全局使用的类频繁的创建和销毁的问题**。单例模式下可以**确保某一个类只有一个实例**，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是**某个类只能有一个实例**；二是它**必须自行创建这个实例**；三是它必须**自行向整个系统提供这个实例**。

- **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- **主要解决：**一个全局使用的类频繁地创建与销毁。

- **何时使用：**当您想控制实例数目，节省系统资源的时候。

- **如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

- **关键代码：**构造函数是**私有**的。当我们在程序中声明一个对象时，编译器为调用构造函数，由于在class外部不允许访问私有成员，所以这将导致编译出错。

## 单例模式的多线程安全问题：

在单例模式的实现中，如果不采取任何措施，在多线程下是不安全的，可能会同时创建多个实例。因此，为了保证单例模式在多线程下的线程安全，一般采用下面几种方式实现单例模式：

1) 饿汉式：

- 优点：没有加锁，执行效率会提高。

- 缺点：类**加载时就初始化**，浪费内存。

```c++
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
```

2) 懒汉式：

- 线程不安全：

  **描述：**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。

  ```c++
  public class Singleton {  
      private static Singleton instance;  
      private Singleton (){}  
    
      public static Singleton getInstance() {  
      if (instance == null) {  
          instance = new Singleton();  
      }  
      return instance;  
      }  
  }
  ```

- 线程安全

  - 优点：**第一次调用才初始化**，避免内存浪费。

  - 缺点：必须**加锁** synchronized 才能保证单例，但加锁会**影响效率**。

  ```c++
  public class Singleton {  
      private static Singleton instance;  
      private Singleton (){}  
      public static synchronized Singleton getInstance() {  
      if (instance == null) {  
          instance = new Singleton();  
      }  
      return instance;  
      }  
  }
  ```

## [工厂模式](https://www.cnblogs.com/heliusKing/p/11577837.html)

- **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

- **主要解决：**主要解决接口选择的问题。

- **何时使用：**我们明确地计划不同条件下创建不同实例时。

- **如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

- **关键代码：**创建过程在其子类执行。

## [抽象工厂模式](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

- **意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

- **主要解决：**主要解决接口选择的问题。

- **何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

- **如何解决：**在一个产品族里面，定义多个产品。

- **关键代码：**在一个工厂里聚合多个同类产品。

- **优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

- **缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

## [简单工厂模式、工厂模式和抽象工厂模式的区别及各自的优缺点](https://www.cnblogs.com/wikis/p/11738149.html)

- **简单工厂模式**(又叫静态工厂模式)

  本质是**通过传入不同的参数来实现多态，达到实例化不同对象的目的。**

  【优点】

  - 客户端创建对象时只需要记住特定的参数，而不需要记住复杂的类名，也不用关注实现的过程。(实现了封装和部分解耦)

  - 创建对象不需要单独实例化，而是通过工厂类直接获取示例(实现复用)

  【缺点】

  - 实例化对象的逻辑全部封装在一个工厂类里，每次需求变化都要单独修改工厂类(违反了开放-封闭原则)，而且出了异常可能没法正常工作。

  - 不方便扩展子类

  【应用场景】

  - 适合业务简单或者产品较少的情况



- **工厂模式**(又称为创建模式)

  是对简单工厂模式多了一层抽象，将实例化某一类对象具体细分给对应的工厂，而不是在一个工厂里通过依赖参数。

  【优点】

  - 在简单工厂的基础上遵循了开放-封闭原则，又进行了解耦，工厂类分为具体的工厂类

  【缺点】

  - 每增加一个工厂，就要额外开发一个工厂

  【应用场景】

  - 正文中符合工厂模式的情况，多由于解耦

- **抽象工厂模式**

  是对工厂模式又进行了一层抽象，不单单是像工厂模式只生成一类产品，而是一系列产品，并且可以像零件一样灵活配置给各工厂。

  【优点】

  - 正是由于复杂的抽象关联关系使得在类的内部对一系列产品组的管理很方便

  【缺点】

  - 扩展很费力，每次要修改很多类。

  【应用场景】

  - 待创建的对象是一系列相互关联或相互依赖的产品族时

## [观察者模式](https://www.cnblogs.com/carsonzhu/p/5770253.html)

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

- **意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

- **主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

- **何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

- **如何解决：**使用面向对象技术，可以将这种依赖关系弱化。

- **关键代码：**在抽象类里有一个 ArrayList 存放观察者们。

- **优点：** 
  - 观察者和被观察者是抽象耦合的。
  - 建立一套触发机制。

- **缺点：** 
  - 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 
  - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
  - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

- **使用场景：**

  - 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。

  - 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。

  - 一个对象必须通知其他对象，而并不知道这些对象是谁。

  - 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

## [观察者模式和发布订阅模式的区别](https://www.jianshu.com/p/594f018b68e7)

观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心
