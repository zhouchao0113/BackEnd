# 补充知识

## 能不能在头文件中定义全局变量？

因为变量只能被定义一次，包含了头文件的源文件，都将会定义同样的全局变量，造成冲突，所以，头文件中不能定义全局变量。

一般在源文件中定义，然后在头文件中用extern声明。

## 内存泄漏怎么办

- 从程序内部重新编译。养成良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露。

- 结束程序，内存自然就会被操作系统回收。

- 重新启动电脑后，立刻恢复。

## const常量与define宏定义的区别

- **编译器处理方式**不同
- define宏是在预处理阶段展开。
  - const常量是编译运行阶段使用。
- **类型和安全检查**不同
- define宏没有类型，不做任何类型检查，仅仅是展开。
  - const常量有具体的类型，在编译阶段会执行类型检查。
- **存储方式**不同
- define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
  - const常量会在内存中分配(可以是堆中也可以是栈中)。

## [explicit关键字](https://www.cnblogs.com/rednodel/p/9299251.html)

- 对于单参数的构造函数，C++会**默认将参数对应的类型转换为该类类型**，有时候这种隐式的转换是我们所不想要的，所以需要使用explicit来限制这种转换。
- C++中的explicit关键字**只能用于修饰只有一个参数的类构造函数**, 它的作用是表明该构造函数是显式的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).
- explicit关键字只需用于类内的单参数构造函数前面。由于**无参数的构造函数**和**多参数的构造函数总是显式调用**，这种情况在构造函数前加explicit无意义。

```c++
Test2 t2=12; //隐式调用
Test2 t2(12);//显式调用
```

## 一个进程,有多少个堆和栈

一个进程一个堆，一个线程一个栈

堆≈虚拟内存大小-1GB

栈通常为4MB（与操作系统有关）

## 子线程退出了，其他线程会怎么样？

如果调用pthread_exit()的话，只会使主函数所在的线程（可以说是进程的主线程）退出；而如果是return或exit，从而导致进程及其所有线程结束运行（因为线程依赖于进程）。



## 线程同步、线程安全、线程死锁

1. **线程同步**，当软件中要用到多线程，当1号线程运行变量要等待另2号线程的结果时，1号和2号线程就要同步，也就是一百个线程要等待另一个线程，或度是相互等待。
2. **线程安全（互斥）**，比两个或两个以上线程要同时操作（主要指写操作）一个全局变量时，这个时间点不能相同，这样两个线程的操作会造成程序崩溃，这个状态称为线程不安全（一般用全局信号量来调整两个线程的写入时间点，防止冲突）
3. **线程死锁**，多个线程争夺同一个资源时造成的相互等待的现象。

## 线程崩溃是否会造成进程崩溃？

线程有自己的 stack，但是没有单独的 heap，也没有单独的 address space，所以只能是整个进程一起崩溃。

## 多态的意义

**多态**：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

**把不同的子类对象都当作父类来看**，**可以屏蔽不同子类对象之间的差异**，写出通用的代码，做出通用的编程，以适应需求的不断变化。赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。也就是说，父亲的行为像儿子，而不是儿子的行为像父亲。

## 纯虚函数报错问题

在构造和析构中调用**虚函数**采用静态联编。

在构造和析构中调用**纯虚函数**会报错。

## 初始化列表初始化顺序

初始化列表是按**类中声明变量的先后顺序**来初始化，与初始化列表的顺序无关。

## linux多线程程序创建

```c++
//线程号
pthread_t tid;
//线程创建
pthread_create(&tid, NULL, tfn, NULL);
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
//线程退出
void pthread_exit(void *retval);
//线程分离
int pthread_detach(pthread_t thread); 
```



## 通过互斥锁实现多线程程序对数据的排他访问

创建两个线程，定义一个共有数据，对数据访问前先加锁，再访问，访问完再解锁。

```c++
//头文件
#include <pthread.h>
//定义锁
pthread_mutex_t mutex;
//初始化锁
pthread_mutex_init(&mutex, NULL);
//加锁
pthread_mutex_lock(&mutex);
//解锁
pthread_mutex_unlock(&mutex);
//销毁锁
pthread_mutex_destroy(&mutex);

void *tfn(void *arg)
{
    srand(time(NULL));

    while (1) {

        pthread_mutex_lock(&mutex); //多线程的任务处理要在死循环中进行
        printf("hello ");
        sleep(rand() % 3);	/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/
        printf("world\n");
        pthread_mutex_unlock(&mutex);

        sleep(rand() % 3);

    }

    return NULL;
}
```

## 条件变量实现生产者消费者模型

生产者消费者模型是指：生产者生产产品，消费者消费产品，两者按序进行。

- 首先设置一个产品链表（需用互斥量保护）。
- 初始化条件变量和生产者、消费者线程。
- 如果产品为空，则消费者阻塞等待一个条件变量。
- 生产者制造一个产品，并将等待在该条件变量上的一个线程唤醒。此时消费者线程被唤醒消费产品。

```c++
//初始化条件变量和互斥量
pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
//初始化生产者消费者线程
pthread_create(&pid, NULL, producer, NULL);
pthread_create(&cid, NULL, consumer, NULL);
//阻塞等待一个条件变量，并释放已掌握的互斥锁
pthread_cond_wait(&has_product, &lock);
//唤醒阻塞在某个条件变量上的线程
pthread_cond_signal(&has_product);
//销毁条件锁
pthread_cond_destroy(&has_product)
```

条件变量的优点：

- 相较于 mutex 而言，条件变量可以**减少竞争**。如直接使用 mutex，除了生产者、消费者之间要竞争互斥量以外，**消费者之间也需要竞争互斥量**，但如果链表中没有数据，**消费者之间竞争互斥锁是无意义的**。
- 有了条件变量机制以后，**只有生产者完成生产，才会引起消费者之间的竞争**。提高了程序效率。  

## 信号量实现生产者消费者模型

如果产品队列满，生产者不能生产，如果产品队列空，消费者不能消费。

- 设置一个产品队列，空格子信号量, 产品信号量
- 初始化生产者和消费者线程
- 生产者将空格子信号量减一（如果信号量为0则组设等待），生产产品，将产品数信号量加一（如果信号量大于0则唤醒消费者线程）
- 消费者将产品数信号减一,为0则阻塞等待，消费产品，将空格子数信号量加一（如果信号量大于0则唤醒生产者者线程）

```c++
//设置产品队列
int queue[NUM];   
//设置空格子信号量，产品信号量
sem_t blank_number, product_number;    
//初始化生产者和消费者线程
pthread_create(&pid, NULL, producer, NULL);
pthread_create(&cid, NULL, consumer, NULL);
//将空格子信号量减一，将产品数信号量加一
sem_wait(&blank_number); //生产者将空格子数--,为0则阻塞等待
sem_post(&product_number); 
//将产品数信号减一，将空格子数信号量加一
sem_wait(&product_number);
sem_post(&blank_number);
//销毁信号量
sem_destroy(&blank_number);
```

## 互斥锁、读写锁、条件变量、信号量的区别

**互斥锁**(又名互斥量）**强调的是资源的互斥访问**：**互斥锁是用在多线程多任务互斥的**，一个线程占用了某一个资源，那么**别的线程就无法访问**，直到这个线程unlock，其他的线程才开始可以利用这个资源。比如对全局变量的访问，有时要加锁，操作完了，再解锁。

**读写锁**在**写加锁状态**时，在这个锁被解锁之前，所有试图对这个锁加锁的线程**都会被阻塞**。当读写锁在**读加锁状态**时，所有试图以读模式对它进行加锁的线程**都可以得到访问权**，但是如果线程希望以写模式对此锁进行加锁，它必须阻塞直到所有的线程释放读锁。

**条件变量**常与互斥锁同时使用，达到线程同步的目的：条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足。在**发送信号时，如果没有线程等待在该条件变量上，那么信号将丢失**。

**信号量**强调的是**线程（或进程）间的同步**：“信号量用在多线程多任务同步的，**一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作**。信号量不一定是锁定某一个资源，而是**流程上的概念**，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进行操作。

## 构造函数中可以调用虚函数吗？

可以，但是没有意义，**父类的构造函数中调用的是父类的虚函数**，在**子类中调用的是子类的虚函数**。父类中不可以调用纯虚函数！

- 基类部分在派生类部分之前被构造，**当基类构造函数执行时，派生类中的数据成员还没被初始化**。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
- 因为虚表指针是放在顶部的，**先初始化虚表指针**，指向虚表（**虚表在编译期就生成**），**之后按照声明顺序初始化成员变量**。**最后调用构造函数{ }中的代码**。

## 子类的构造过程

1. 从main函数跳转到子类的构造函数
2. 再跳转到父类的构造函数
3. 执行父类的构造函数
4. 跳转到子类的构造函数并执行

## 子类创建对象时的内存空间分配

1. 子类中声明的成员变量被分配了内存空间
2. 父类的**成员变量也都分配了内存空间**
3. 但只将其中一部分（子类继承的那部分）作为分配给子类对象的变量（就是说没继承的那部分虽然有空间但也不作为子类的成员变量）
4. 没继承那部分不就是垃圾了吗，有意义吗，其实你要注意，子类有一部分方法是从父类中继承的，而这部分方法**可以操作那些没有继承的变量**

## 在构造函数当中一部分是初始化列表一部分是在花括弧里面，你能说一下这些的顺序是什么么？

构造函数会首**先根据初始化列表中的值初始化对应的成员变量**，当某个成员变量被初始化列表忽略时，会对其进行默认初始化。执行完这个过程之后才会执行花括弧中的构造函数体。花括弧中的构造函数体执行的都是**赋值操作**，而不是**初始化操作**。

初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值，除了效率问题更重要的是，**一些数据成员必须被初始化**，例如，如果成员是**const类型**或者是**引用类型**或者**成员属于某种类型且该类型没有定义默认构造函数时**，就必须将其初始化。

## 初始化和赋值的区别

- **赋值操作**是在两个已经存在的对象间进行的。
- **初始化**是要创建一个新的对象，并且其**初值来源于另一个已存在的对象**。
- 编译器会区别这两种情况，**赋值**的时候调用**重载的赋值运算符**，**初始化**的时候调用**拷贝构造函数**。如果类中没有拷贝构造函数，则编译器会提供一个默认的。这个默认的拷贝构造函数只是简单地复制类中的每个成员。
- 静态变量的初始化是在**编译**时进行，变量的赋值是在函数或程序**运行**时进行。

## 初始化列表的写法和顺序有没有什么关系？

没有。

初始化列表的写法和顺序没有关系，初始化列表**只是说明用于初始化成员的值**，而**不限定初始化的具体执行顺序**。成员的**初始化顺序与他们在类定义中的出现顺序一致**：第一个成员先被初始化，然后是第二个成员，依次类推。

## 虚继承

虚继承是让某个类做声明，承诺愿意共享他的基类，**共享的基类**被称为虚基类，在这种机制下，不论虚基类在继承体系下出现多少次，在派生类中都**只包含唯一一个共享的虚基类对象**。

## 没有继承关系时的构造过程

1. **分配内存**
2. **先构造虚表指针**，对虚表指针赋值（如果有虚函数才会进行这一步）
3. 根据**初始化列表中的值初始化对应的成员变量**，当某个成员变量被初始化列表忽略时，会对其进行默认初始化。
4. 执行**构造函数**

## 存在一般继承关系时的构造过程

1. **分配内存**
2. **先进行父类的构造**，以父类的声明顺序为顺序，如果父类依然存在父类，就会先构造更早的父类，依次类推。如果父类位于初始化列表中，那么任何显示指定的参数都会被传递过去，如果没有位于初始化列表中，如果父类存在默认构造函数，就会调用这个默认构造函数，父类的构造过程同子类。（类似于递归的一个过程）
3. 先构造**虚表指针**，对虚表指针赋值
4. 根据**初始化列表**中的值初始化对应的成员变量，当某个成员变量被初始化列表忽略时，会对其进行默认初始化。
5. 执行**构造函数**体

## 存在虚继承关系时的构造过程

和一般的继承体系有所区别，因为所有的派生类都**共享唯一一个虚基类对象**，所以**虚基类对象的构造过程只能发生一次**，这一次发生在**最深层的派生类**中，具体来讲，虚继承体系的每一层都会先条件式的测试传进来的某个参数，根据这个参数来判断是否调用虚基类的构造函数，具体的过程如下

1. **分配内存**
2. 条件式的测试传进来的参数，根据这个参数来**判断是否调用虚基类的构造函数**，然后设置这个参数，使得**继承体系更上一层的父类不会再调用虚基类的构造函数**，所以**虚基类对象的构造过程始终发生在最深层的派生类中**。
3. 进行**父类的构造**，以父类的声明顺序为顺序，如果父类依然存在父类，就会先构造更早的父类，依次类推。如果父类位于初始化列表中，那么任何显示指定的参数都会被传递过去，如果没有位于初始化列表中，如果父类存在默认构造函数，就会调用这个默认构造函数，父类的构造过程同子类。（类似于递归的一个过程）
4. 初始化列表之前先**构造虚表指针**，对虚表指针赋值
5. 根据**初始化列表**中的值初始化对应的成员变量，当某个成员变量被初始化列表忽略时，会对其进行默认初始化。
6. 执行**构造函数**体

## 是先构造父类的虚表指针还是先构造父类的成员？

先构造父类的虚表指针，再构造父类的成员

## 虚表指针是什么时候设进去的？

在**初始化列表之前**构造虚表指针，在**调用父类构造函数之后**构造虚表指针。

## 虚表指针在初始化列表之前被赋值，可以放在初始化列表之后赋值吗？即顺序是：列表初始化、虚表指针赋值、构造函数体？

正确顺序应该是**虚表指针赋值、列表初始化、构造函数体**。

如果虚表指针的初始化在初始化列表之后的话，可能会在**初始化列表中使用到一个虚函数**！！！
那么在调用此虚函数的时候，应该访问哪个虚表呢？是基类的虚表？还是当前类的虚表？毫无疑问，**应该是当前类的虚表**！！！

但是在调用此虚函数的时候，虚表指针并未赋值为子类的虚表，所以无法访问当前类的虚函数，访问的依旧是基类的虚函数。

因此，将虚表指针的赋值过程应该放置在初始化列表之前，这是为了**防止在初始化列表出现调用虚函数**的情况！


## tcp和udp可以监听同一个端口吗？

可以。

```c++
#include <sys/socket.h>
int bind(int socket, const struct sockaddr *address,socklen_t address_len);
```

sockaddr参数是一个套接字地址结构。
sockaddr结构如下:

```c++
	sa_family_t    sin_family    /*协议*/
	in_port_t      sin_port      /*端口*/
	struct in_addr sin_addr      /*ip*/
	unsigned char  sin_zero[8]   /*sizeof(struct sockaddr)*/
```

可以看到linux是**以协议、ip、端口来绑定ip和端口的**，所以不同协议相同的ip和端口也是可以绑定成功的。

## 虚函数的底层实现机制

每个类使用一个虚函数表，每个类对象用一个指向虚函数表的指针。如果派生类重写了基类的虚方法，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

## 智能指针shared_ptr的实现

```c++
核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存

template <typename T>

class SmartPtr

{

private:

T *ptr;    //底层真实的指针

int *use_count;//保存当前对象被多少指针引用计数

public:

SmartPtr(T *p); //SmartPtr<int>p(new int(2));

SmartPtr(const SmartPtr<T>&orig);//SmartPtr<int>q(p);

SmartPtr<T>&operator=(const SmartPtr<T> &rhs);//q=p

~SmartPtr();

T operator*();  //为了能把智能指针当成普通指针操作定义解引用操作

T*operator->();  //定义取成员操作

T* operator+(int i);//定义指针加一个常数

int operator-(SmartPtr<T>&t1,SmartPtr<T>&t2);//定义两个指针相减

void getcount() { return *use_count } }; template <typename T> int SmartPtr<T>::operator-(SmartPtr<T> &t1, SmartPtr<T> &t2) { return t1.ptr-t2.ptr; } template <typename T> SmartPtr<T>::SmartPtr(T *p) { ptr=p; try { use_count=new int(1); }catch (...) {
delete ptr;    //申请失败释放真实指针和引用计数的内存

ptr= nullptr; delete use_count; use_count= nullptr; } } template <typename T>
SmartPtr<T>::SmartPtr(const SmartPtr<T> &orig) //复制构造函数

{

use_count=orig.use_count;//引用计数保存在一块内存，所有的SmarPtr对象的引用计数都指向这里

this->ptr=orig.ptr;

++(*use_count);//当前对象的引用计数加1


} template <typename T> SmartPtr<T>& SmartPtr<T>::operator=(const SmartPtr<T> &rhs) {
//重载=运算符，例如SmartPtr<int>p,q; p=q;这个语句中，首先给q指向的对象的引用计数加1，因为p重新指向了q所指的对象，所以p需要先给原来的对象的引用计数减1，如果减一后为0，先释放掉p原来指向的内存，然后讲q指向的对象的引用计数加1后赋值给p

++*(rhs.use_count); if((--*(use_count))==0) { delete ptr; ptr= nullptr; delete use_count; use_count= nullptr; } ptr=rhs.ptr; *use_count=*(rhs.use_count); return *this; } template <typename T> SmartPtr<T>::~SmartPtr() { getcount();
if(--(*use_count)==0)  //SmartPtr的对象会在其生命周期结束的时候调用其析构函数，在析构函数中检测当前对象的引用计数是不是只有正在结束生命周期的这个SmartPtr引用，如果是，就释放掉，如果不是，就还有其他的SmartPtr引用当前对象，就等待其他的SmartPtr对象在其生命周期结束的时候调用析构函数释放掉
{
getcount();
delete ptr;
ptr= nullptr;
delete use_count;
use_count=nullptr;
}
}
template <typename T>
T SmartPtr<T>::operator*()
{
return *ptr;
}
template <typename T>
T*  SmartPtr<T>::operator->()
{
return ptr;
}
template <typename T>
T* SmartPtr<T>::operator+(int i)
{
T *temp=ptr+i;
return temp;
}
}

```

## C++函数栈空间的最大值

默认是1M，不过可以调整

## STL有什么基本组成

STL主要由：以下几部分组成：**容器**、**迭代器**、仿函数、**算法**、**分配器**、配接器。
他们之间的关系：**分配器给容器分配存储空间**，**算法通过迭代器获取容器中的内容**，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

## STL中迭代器的作用，有指针为何还要迭代器

1、迭代器

Iterator模式是运用于聚合对象的一种模式，通过运用该模式，**使得我们可以在不知道容器内部表示的情况下，按照一定顺序（由iterator提供的方法）访问容器中的各个元素**。

2、迭代器和指针的区别

**迭代器不是指针，是类模板，表现的像指针**。他只是**模拟了指针的一些功能**，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

**迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器**使用*取值后的值**而不能直接输出其自身。

3、迭代器产生原因

Iterator类的访问方式就是把**不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果**。

## 请你说一说STL迭代器是怎么删除元素的呢

这个主要考察的是**迭代器失效**的问题。

1.对于**序列容器vector,deque**来说，使用erase(itertor)后，**后边的每个元素的迭代器都会失效**，后边每个元素都会往前移动一个位置，但是**erase会返回下一个有效的迭代器**；

2.对于**关联容器map set**来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。

3.对于**list**来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

## STL里resize和reserve的区别

**resize()**：改变**当前容器内含有元素的数量**(size())。

**reserve()**：改变**当前容器的最大容量**（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；

## C++中struct和class的区别

在C++中，可以用struct和class定义类，都可以继承。区别在于：struct的**默认继承权限和默认访问权限**是public，而class的默认继承权限和默认访问权限是private。

另外，class还可以定义模板类形参，比如template <class T, int i>。

## C++类内可以定义引用数据成员吗？

可以，**必须通过成员函数初始化列表初始化**。

## 什么是右值引用，跟左值又有什么区别？

右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：

1. **消除两个对象交互时不必要的对象拷贝**，节省运算存储资源，提高效率。
2. 能够更简洁明确地定义泛型函数。

为了支持移动操作，c++新标准引入了一种新的引用类型—右值引用。所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们将要看到的，右值引用有一个重要的性质—只能绑定到一个将要销毁的对象。 因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。

```c++
int i=42;
int &r=i;   //正确，r引用i
int &&rr=i   //错误，不能将一个右值引用绑定到一个左值上
int &r2=i*42;  //错误，i*42是一个右值
const int &r3=i*42;  //正确，我们可以将一个const的引用绑定到一个右值上
int &&r2=i*42; //正确，将rr2绑定到乘法结果上
```



左值和右值的概念：

**左值**：**能对表达式取地址、或具名对象/变量**。一般指表达式结束后依然存在的持久对象。

**右值**：**不能对表达式取地址，或匿名对象**。一般指表达式结束就不再存在的临时对象。



右值引用和左值引用的区别：

1. **左值可以寻址，而右值不可以**。

2. **左值可以被赋值，右值不可以被赋值**，可以用来给左值赋值。

3. **左值可变,右值不可变**（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。

## 请你来说一下一个C++源文件从文本到可执行文件经历的过程？

对于C++源文件，从文本到可执行文件一般需要四个过程：

**预编译阶段**：对源代码文件中文件包含关系（**头文件**）、预编译语句（**宏定义**）进行**分析和替换**，**生成预编译文件**。

**编译阶段**：将经过预处理后的**预编译文件转换成特定汇编代码**，生成汇编文件

**汇编阶段**：将编译阶段生成的**汇编文件转化成机器码**，生成可重定位目标文件

**链接阶段**：将多个目标文件及所需要的库连接成最终的可执行目标文件

## malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？

Malloc函数用于**动态分配内存**。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc会**通过隐式链表遍历所有的空闲块**，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。

Malloc在申请内存时，一般**会通过brk或者mmap系统调用进行申请**。其中**当申请内存小于128K时，会使用系统函数brk在堆区中分配**；而**当申请内存大于128K时，会使用系统函数mmap在映射区分配**。

## C++的内存管理是怎样的？

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

**代码段**:包括只读存储区和文本区，其中只读存储区存储**字符串常量**，文本区存储程序的**机器代码**。

**数据段**：存储程序中**已初始化的全局变量和静态变量**

**bss 段**：存储**未初始化的全局变量和静态变量（局部+全局）**，以及所有**被初始化为0的全局变量和静态变量**。

**堆区**：调用new/malloc函数时在堆区**动态分配内存**，同时需要调用delete/free来手动释放申请的内存。

**映射区**:存储动态链接库以及调用mmap函数进行的文件映射

**栈**：使用栈空间存储**函数的返回地址、参数、局部变量、返回值**

## 如何判断内存泄漏？

内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的**内存泄漏检查工具**Valgrind,另一方面我们在**写代码时可以添加内存申请和释放的统计功能**，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

## 什么时候会发生段错误

**段错误**通常发生在**访问非法内存地址**的时候，具体来说分为以下几种情况：

**使用野指针**

**试图修改字符串常量的内容**

## select、poll、epoll

1、select

select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。

存在的问题：

1. 内置**数组**的形式使得select的**最大文件数受限**与FD_SIZE；

2. 每次调用select前都要**重新初始化描述符集**，**将fd从用户态拷贝到内核态**，每次调用select后，都需要将fd从内核态拷贝到用户态；

3. 轮寻排查当文件描述符个数很多时，效率很低；

2、poll

poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。

3、epoll

epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式

## epoll怎么实现的

Linux epoll机制是通过**红黑树和双向链表**实现的。 

- 首先通过**epoll_create()**系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。
- 然后通过**epoll_ctl()**系统调用，**向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件**，返回0标识成功，返回-1表示失败。
- 最后通过**epoll_wait()**系统调用**判断双向链表是否为空**，如果**为空则阻塞**。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，**返回就绪好的事件**。

## C++11有哪些新特性？

C++11 最常用的新特性如下：

**auto关键字**：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导

**nullptr关键字**：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。

**智能指针**：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。

初始化列表：使用初始化列表来对类进行初始化

**右值引用**：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率

atomic原子操作用于多线程资源互斥操作

新增STL容器array以及tuple

## [各数据类型的大小和取值范围](https://blog.csdn.net/weixin_42856843/article/details/81989737)

**有符号整数类型**

| 类型名称                   | 字节数 | 取值范围                                                  |
| -------------------------- | ------ | --------------------------------------------------------- |
| signed char                | 1      | -2^7(-128) ~ 2^7-1(127)                                   |
| short int 或 short         | 2      | -2^15(-32 768) ~ 2^15-1(32 767)                           |
| int                        | 4      | -2^31(-2 147 483 648) ~ 2^31-1(2 147 483 647)             |
| long int 或 long           | 4      | -2^31(-2 147 483 648) ~ 2^31-1(2 147 483 647)             |
| long long int 或 long long | 8      | -2^63(-9.2233720368548e+18) ~ 2^63-1(9.2233720368548e+18) |

3位机（8位机为2^8）的话总长度是2^3，对有符号数来说各占一半，也就是2^2=4，也就是三位机的int范围为(-4~+4)，但是0被划到了正数的范畴，所以三位机中int的范围应该是(-4~+3). 同理，是[-2^31,2^31-1]而不是[-2^31,2^31]

## const和volatile是否可以同时修饰一个变量

 const和volatile是可以同时修饰一个变量的 const只是表示变量只读 不能出现在赋值号左边 防止程序“意外”修改  并且编译器一定会做优化 不会每次去内存取值 这个时候如果外部事件 如中断服务程序 改了这个变量的内存值 那么由于编译器优化就不会出有反应 这样会导致错误 加上volatile就告诉编译器 不要做任何优化 并且每次都去内存取值 而且这个变量不可以当左值使用 。



## [链表中的环问题](https://www.cnblogs.com/xudong-bupt/p/3667729.html)

## [topK问题](http://blog.itpub.net/31556838/viewspace-2215550/)

## [判断无向图是否联通](https://www.jianshu.com/p/54a2dd647491)

## [kmp](https://segmentfault.com/a/1190000008575379)

```
#include <iostream>
#include <string>

using namespace std;

/* P 为模式串，下标从 0 开始 */
void GetNext(string P, int next[])
{
	int p_len = P.size();
	int i = 0;   // P 的下标
	int j = -1;
	next[0] = -1;

	while (i < p_len)
	{
		if (j == -1 || P[i] == P[j])
		{
			i++;
			j++;
			next[i] = j;
		}
		else
			j = next[j];
	}
}

/* 在 S 中找到 P 第一次出现的位置 */
int KMP(string S, string P, int next[])
{
	GetNext(P, next);

	int i = 0;  // S 的下标
	int j = 0;  // P 的下标
	int s_len = S.size();
	int p_len = P.size();

	while (i < s_len && j < p_len) // 因为末尾 '\0' 的存在，所以不会越界
	{
		if (j == -1 || S[i] == P[j])  // P 的第一个字符不匹配或 S[i] == P[j]
		{
			i++;
			j++;
		}
		else
			j = next[j];  // 当前字符匹配失败，进行跳转
	}

	if (j == p_len)  // 匹配成功
		return i - j;

	return -1;
}

int main()
{
	int next[100] = { 0 };

	cout << KMP("bbc abcdab abcdabcdabde", "abcdabd", next) << endl; // 15

	return 0;
}
```

