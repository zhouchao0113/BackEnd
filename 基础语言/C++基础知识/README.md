# C++基础知识

[TOC]

## 说一下C++和C的区别

- 设计思想上：
  - C++是面向对象的语言，而C是面向过程的结构化编程语言

- 语法上：

  - C++具有封装、继承和多态三种特性

  - C++相比C，增加多许多类型安全的功能，比如强制类型转换。

  - C++支持范式编程，比如模板类、函数模板等

## 数组和指针的区别

> * **概念不同.** 指针相当于一个变量，它存放的是数据在内存中的地址；数组是用于储存多个相同类型数据的集合
> * **赋值不同.** 同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝
> * **访问数据不同.** 指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容；数组是直接访问
> * **sizeof意义不同.** 
>   数组所占存储空间的内存：sizeof（数组名）
>   数组的大小：sizeof（数组名）/sizeof（数据类型）
>   在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8
> * **指针和数组名异同.** 指针和数组名都可以表示地址，但指针是变量，可以修改；数组名是常量，不可修改赋值
> * **传参.** 
>   数组传参时会退化成指针

1. 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。
2. 因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。

## 请说一下C/C++ 中指针和引用的区别？

- 指针有自己的一块空间，而引用只是一个别名；
- 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
- 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
- 可以有const指针，但是没有const引用；
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
- 指针可以有多级指针（**p），而引用至于一级；
- 指针和引用使用++运算符的意义不一样；
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

## 指针数组和数组指针

指针数组本质是数组，数组指针本质是指针，谁优先级高，本质是谁

> * 指针数组：它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素。
>   int\* arr[8];

1. 优先级问题：[]的优先级比\*高
2. 说明arr是一个数组，而int\*是数组里面的内容
3. 这句话的意思就是：arr是一个含有8和int*的数组

> * 数组指针：它实际上是一个指针，该指针指向一个数组。
>   int (\*arr)[8];

1. 由于[]的优先级比\*高，因此在写数组指针的时候必须将\*arr用括号括起来
2. arr先和\*结合，说明p是一个指针变量
3. 这句话的意思就是：指针arr指向一个大小为8个整型的数组。

## 字符数组和字符串常量

char    arr[]="hello";  //字符数组 **（可修改）**
char    \*arr2="hello"; //字符串常量**（不可修改）**

> * char arr[]="hello"，此处的赋值是将常量区的字符串"hello"拷贝到了堆栈区的数arr的空间了。数组arr是在堆栈区开辟了空间，此时是可以修改字符串的值，因为修改的是堆栈区的字符串的值。另外此时的数组名p是堆栈区中的"hello"的首地址。
> * char \*arr2="hello"，指针arr2是存储在堆栈区，但字符串是常量，存储在常量区，只是指针arr指向了存储在常量区的字符串首地址，此时不能改变常量区的字符串的值。

const char arr[]="hello";  //这里hello本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
const char \*arr2="hello"; //字符串hello保存在常量区，const本来是修饰arr2指向的值不能通过arr2去修改，但是字符串hello在常量区，本来就不能改变，所以加不加const效果都一样 

## 重载、覆盖、重写

- **重载**(overload)：**是函数名相同，参数列表不同**。重载只是在同一个类的内部存在，但是不能靠返回类型来判断
- **覆盖**(override)：子类重新定义父类中有相同名称和参数的虚函数。
  - 被重写的函数不能是static的。必须是virtual的
  - 重写函数必须有相同的类型，名称和参数列表
  - 重写函数的访问权限可以不同。尽管virtual是private的，子类中重写改写为public,protected也是可以的。
- **重写**(overwrite)：也叫做隐藏。子类重新定义父类中有相同名称的**非虚函数** ( **参数列表可以不同** ) 。如果一个类，存在和父类相同的函数，那么，这个类**将会隐藏其父类的方法**，除非你在调用的时候，**强制转换为父类类型或加上父类作用域**

## [C++中虚函数的作用和多态](https://www.cnblogs.com/zkfopen/p/11061414.html)

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。

## 虚函数的底层实现机制

每个类使用一个虚函数表，每个类对象用一个指向虚函数表的指针。如果派生类重写了基类的虚方法，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

## [请你说说C语言是怎么进行函数调用的？](https://blog.csdn.net/yanerhao/article/details/69258885)

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把函数参数压栈，在把返回地址压栈，执行函数体，返回地址出栈，函数参数一次出栈，函数执行完毕。

## 请你说说C语言参数压栈顺序？

从右到左

## 引用和指针的区别

> * **指针有内存分配，而引用只是一个别名.** 引用声明时必须初始化，从而指向一个已经存在的对象
> * **引用可以看做常量指针，指针是一个存储地址的变量.** 指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。
> * **引用创建时必须初始化，且不为空，指针创建时可以为空.** 不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
> * **指针和引用的自增运算符意义不同.** 指针是对内存地址的自增，引用是对值的自增
> * **sizeof的意义不同.** 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小
> * **没有引用常量，有指针常量.** 没有int& const p,有int\* const p.
>   常量指针和常量引用是存在的，const int \*p和cosnt int &p，都表示指向的对象为常量常量引用形参的好处：（1）使用引用作为形参，不会产生新的变量，减少形参和实参传递的开销；（2）使用引用可能会导致实参随着形参的改变而改变。声明为const之后就会消除这种副作用。
> * **参数传递.** 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象
> * **多级指针，一级引用.** 指针可以有多级指针（\*\*p），而引用只有一级

## C++中class和struct的区别

C中的strcut不能有函数，但C++中可以。C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。struct能包含成员函数吗？ 能！struct能继承吗？ 能！！struct能实现多态吗？ 能！！！

> * **默认的继承访问权限.** struct是public的，class是private的
>   class B : public A就是为了指明是public继承，而不是用默认的private继承，若class B : A则是private继承
> * **定义模板参数.** class这个关键字还用于定义模板参数，就像typename。但关键字struct不用于定义模板参数。

## new/delete和malloc/free区别

malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0。另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数

> * **属性不同.** new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c
> * **申请的内存所在位置.** new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存.
> * **返回类型安全性.** new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
>   而malloc内存分配成功则是返回void*类型，需要通过强制类型转换将空类型指针转换成我们需要的类型。
> * **内存分配失败时的返回值.** new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
> * **是否需要指定内存大小.** 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的大小
>   int *pi=new int;//在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi。
>   int *pi=new int();//对指针pi指向的地址的值进行了初始化为0
>   int *pi=new int(1024);//初始化为1024。
>   int *p=(int *)malloc(100);//指向整型的指针p指向一个大小为100字节的内存的地址
>   int *p=(int *)malloc(25*sizeof(int));//指向整型的指针p指向一个25个int整型空间的地址
> * **数组分配内存（与前一个特点类似）.** new中分配内存对于变量和数组不同，malloc分配内存则相同
>   int *pi=new int[];  //指针pi所指向的数组未初始化
>   int *pi=new int[n]; //指针pi指向长度为n的数组，未初始化
>   int *pi=new int[]();  //指针pi所指向的地址初始化为0
> * **是否调用构造函数/析构函数.**   new会先调用operator_ new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_ delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 
> * **能否重载.** opeartor_new/operator_delete允许重载,malloc/free不允许重载
> * **已分配内存的扩充.** malloc/free可以通过realloc函数扩充，new/free无法直观地处理
> * **能否相互调用.** operator_new /operator _delete的实现可以基于malloc/free，而malloc的实现不可以去调用new。

## [new运算符的原理](https://blog.csdn.net/hihozoo/article/details/51441521)

* **内存分配**
  *  调用相应的  operator new(size_t) 函数，动态分配内存。如果 operator new(size_t) 不能成功获得内存，则调用 new_handler()函数用于处理new失败问题。如果没有设置 new_handler() 函数或者 new_handler() 未能分配足够内存，则抛出 std::bad_alloc 异常

* **构造函数**
  *  在分配到的动态内存块上 **初始化相应类型的对象（构造函数）**并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void*, void*) 函数释放已经分配到的内存。

## delete运算符的原理

- **析构函数**

  调用相应类型的析构函数，处理类内部可能涉及的资源释放。

- **内存释放**

  调用相应的 `operator delete(void *)` 函数。调用顺序参考上述 `operator new(size_t)` 函数（ADL规则）。

## malloc的内存分配机制

malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存？

> * 首先会**扫描之前由free()所释放的空闲内存块列表**，以求找到尺寸大于或等于要求的一块空闲内存。如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中

## [栈和堆的区别](https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368)

* 管理方式不同
  * 对于**栈**来讲，是由**编译器自动管理**，无需我们手工控制；对于**堆**来说，**释放工作由程序员控制**，容易产生memory leak。
* 空间大小不同
  * 一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M
* 能否产生碎片不同
  * 对于堆来讲，**频繁的new/delete势必会造成内存空间的不连续**，从而造成大量的碎片，使**程序效率降低**。对于栈来讲，则不会存在这个问题，因为栈是**先进后出的队列**，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出
* 生长方向不同
  * 对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长

## [面向对象和面向过程的区别](https://blog.csdn.net/jerry11112/article/details/79027834)

面向对象就是高度实物抽象化、面向过程就是自顶向下的编程

> * **面向过程**就是**分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用**
> * **面向对象**是把**要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为**
> * 面向过程的优缺点
>   1. 优点：**性能比面向对象高**，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
>   2. 缺点：**没有面向对象易维护、易复用、易扩展**
> * 面向对象的优缺点
>   1. 优点：**易维护、易复用、易扩展**，由于面向对象有**封装、继承、多态性**的特性，可以设计出**低耦合**的系统，使系统 更加灵活、更加易于维护 
>   2. 缺点：**性能比面向过程低**

## [inline关键字](https://blog.csdn.net/chenjieyujiayou/article/details/72416817)

为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。

inline函数仅仅是一个**对编译器的建议**，所以**最后能否真正内联，看编译器的意思**，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。比如说虚函数和递归函数，通常，递归函数不应该声明为内联函数

## const关键字(不可修改)

> * 修饰**变量**，说明该变量不可以被改变；
> * 修饰**指针**，分为指向常量的指针和指针常量；int *const p和const int *p
> * **常量引用**，经常用于**形参类型**，即避免了拷贝，又避免了函数对值的修改；
> * 修饰**成员函数，**说明**该成员函数内不能修改成员变量**，本质是const this指针。

## static关键字(对外不可见)

- **全局静态变量**

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.

静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

- **局部静态变量**

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

内存中的位置：静态存储区

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

- **静态函数**

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

- **类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

- **类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

## [extern关键字](https://www.cnblogs.com/qinguoyi/p/10100777.html)

extern关键字主要修饰变量或函数，表示该函数**可以跨文件访问**，或者**表明该变量在其他文件定义，在此处引用**.

> * **修饰变量或函数.**被 extern 限定的函数或变量是 extern 类型的
> * **extern "C".** extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
>
> 1. 在c头文件中通过#ifdef __cplusplus  extern "C"  { #endif来定义

2. 在对应的c文件中实现
3. 在cpp文件中通过“extern "C" 函数名”调用，或者包含c头文件
   **注意：** extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间，但若需要调用的函数太多，还是直接包含头文件吧.


## volatile关键字

> * **不可优化性.** volatile 关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（**操作系统、硬件、其它线程等**）更改。所以使用 volatile 告诉编译器**不应对这样的对象进行优化**。
> * **易变性.** volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）

## explicit关键字

explicit关键字的作用就是防止对象间实现=赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)，另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值.

> * explicit 修饰构造函数时，可以防止隐式转换和复制初始化
> * explicit 修饰转换函数时，可以防止隐式转换

<details>
    <summary>explicit用法</summary>
    <pre><blockcode> 
class Person{
public:
    Person(){
    }
    //有参构造初始化数据
    explicit Person(const char*str_){
        str = (char *)malloc(sizeof(char)*100);
        strcpy(str,str_);
    }
    ~Person() {
        if (str != NULL){
            free(str);
            str = NULL;
        }
    }
    char *str;
};
void test05(){
    //Person p = "abc"; 隐式调用
    Person p ("abc"); //显式调用
}
    </blockcode></pre>
</details>









## 类成员属性

类的成员有三个权限：公有权限（public），私有权限（private），保护权限（protected）。

> * **私有权限.** 私有成员在类内部可以访问，类外不可访问，一般推荐将成员变量设置为私有成员；
> * **公有权限.** 类内类外都可以进行访问；
> * **保护权限.** 类内和当前类的子类可以访问，类外不可访问。

## 大小端序的定义和代码判断

### 定义

一个16进制的地址，存放在内存中从低地址开始存储，如16进制的地址为0x1234，对于地址而言，从右往左是从低到高

* 大端
  * 若16进制的高地址存放在内存的低地址，则为大端字节序，34存储在高位，12存储在低位
* 小端
  * 若16进制的低地址存放在内存的低地址，则为小端字节序，12存储在高位，34存储在高位

### 代码判断

可以通过联合体来判断，联合体是同一块内存被联合体中的所有成员公用，如果后续成员对内存重新赋值，会覆盖内存中原有数据

```C++
union U{
	int a;
	char b;
};

int main(){
	U u;
	u.a = 0x01020304;

	if (u.b == 0x04){
		cout << u.b << endl; //输出char字符
		cout << "little" << endl;
	}

	else if (u.b == 0x01){
		cout << u.b << endl;
		cout << "big" << endl;
	}
	system("pause");
	return 0;
}
```


## 代码判断32位和64位系统

写一个指针，输出指针所占的字节大小

## 左值和右值区别，以及右值是否可以转换成左值

lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。 

rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。

右值可以转换成左值吗？当然不能！根据它的定义这将违反左值的语义。

这并不意味着左值不能通过更加显式的方法产生至右值。例如，一元运算符‘*’（解引用）拿一个右值作为参数而产生一个左值作为结果。

```c++
int arr[] = {1, 2};
int* p = &arr[0];
*(p + 1) = 10;    //对的：p+1是一个右值，但是*(p+1)是一个左值
```

## 请简要介绍一下STL

TL 是 C++ 标准程序库的核心。STL 内的所有组件都由模板构成，其元素可以是任意型别。程序员通过选用恰当的群集类别调用其成员函数和算法中的数据即可，但代价是 STL 晦涩难懂。

STL 组件主要包括容器，迭代器、算法和仿函数。

#### 容器

容器即用来存储并管理某类对象的集合。例如鱼缸是用来盛放金鱼的容器。

每一种容器都有其优点和缺点。为满足程序的各种需求，STL 准备了多种容器类型，容器可以是 arrays 或是 linked lists，或者每个元素有特别的键值。

#### 迭代器

迭代器用于在一个对象群集的元素上进行遍历动作。对象群集可能是容器，也可能是容器的一部分。

迭代器的主要用途是为容器提供一组很小的公共接口。利用这个接口，某项操作可以行进至群集内的下一个元素。

每种容器都提供了各自的迭代器。迭代器了解该容器的内部结构，所以能够正确行进。迭代器的接口和一般[指针](http://c.biancheng.net/c/80/)类似。

#### 算法

算法用来处理群集内的元素，可以出于不同目的搜寻、排序、修改、使用那些元素。所有容器的迭代器都提供一致的接口，通过迭代器的协助，算法程序可以用于任意容器。

STL 的一个特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。

STL 的另一个特性即组件可以针对任意型别运作。“标准模板库”这一名称即表示“可接受任意型别”的模板，并且这些型别均可执行必要操作。

在 STL 中，容器又分为序列式容器和关联式容器两大类，而迭代器的功能主要是遍历容器内全部或部分元素的对象。迭代器可划分为 5 种类属，这 5 种类属归属两种类型：双向迭代器和随机存取迭代器。

SIL 中提供的算法包括搜寻、排序、复制、重新排序、修改、数值运算等。

#### 仿函数

STL中大量运用了仿函数。仿函数具有泛型编程强大的威力，是纯粹抽象概念的例证。

## 内存泄漏分类

- **堆内存泄漏**（heap leak）。堆内存值得是程序运行过程中根据需要分配通过malloc\realloc\new等从堆中分配的一块内存，再完成之后必须要通过调用对应的free或者delete删除。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。

- **系统资源泄露**（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap，handle，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

- **没有将基类的析构函数定义为虚函数**。当**基类指针指向子类对象**时，如果基类的析构函数不是virtual，那么**子类的析构函数将不会被调用**，子类的资源没有正确的释放，从而造成内存泄漏。

## 怎么判断内存泄露

第一：良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露。当程式稳定之后，在来检测内存泄露时，无疑增加了排除的困难和复杂度。使用了内存分配的函数，一旦使用完毕,要记得要使用其相应的函数释放掉。

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

第三：Boost 中的smart pointer。

第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky等等。

## 虚函数可以是内联函数吗？

- **虚函数可以是内联函数**，内联是可以修饰虚函数的，但是当**虚函数表现多态性的时候不能内联**。
- **内联是在编译期进行**，**而虚函数的多态性在运行期**，编译器**无法知道运行期调用哪个代码**，因此虚函数表现为多态性时（运行期）不可以内联。

## c++这一块比较熟悉吧？ 有没有什么类是不能被继承的？

1、如果类被final修饰，那么此类不可以被继承。

2、如果类中只有private的构造方法，那么此类不可以被继承。

 其原因在于：

 （1）一个类一定会有构造函数，如果不写，那就是默认的无参构造函数，如果写，就只有所写的构造函数。

 （2）子类的构造函数一定会调用父类的构造函数，但是如果父类中只有私有的构造方法，那么子类就无法调用父类，就会有问题。

## 如果物理内存是2G 如果malloc 4G可以么？会有什么问题？

不可以

## [位运算](https://www.zhihu.com/question/38206659/answer/736472332)（异或等）

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，<br />各编译器处理方法不一样，有的补符号位（算术右移），<br />有的补0（逻辑右移） |

 
